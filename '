(local g (require :golly))
(local rl (require :raylib))
(local inspect (require :lib.inspect))
(local lume (require :lib.lume))

(local unit-types
  {:scout {}})

(local enemy-types
  {:monster1 {}})

(fn create-unit [t]
  {:id (g.helpers.uuid) :def (. unit-types t) :type t :team :friend})

(fn create-enemy [t]
  {:id (g.helpers.uuid) :def (. enemy-types t) :type t :team :enemy})

(local initial-state
  (let [units [:scout :scout :scout]]
    {:party units}))

(fn reducer [state ...]
  (match ...
    (:goto-battle {: enemies})  
    (lume.merge state
             {:team
              (collect [_ t (ipairs state.party)]
                (let [unit (create-unit t)]
                  (values unit.id unit)))
              :enemies
              (collect [_ t (ipairs enemies)]
                (let [enemy (create-enemy t)]
                  (values enemy.id enemy)))})
    _ initial-state))

(local game-state (g.redux.create-store reducer))

(local background (g.class))
(background:field :z-index -1000)
(background:method :draw {:events [:draw]}
  (fn []
    (rl.DrawRectangle 
      0 0 
      (rl.GetScreenWidth) (rl.GetScreenHeight) 
      (rl.Color 40 50 30 255))))

(local menu (g.class))

(menu:field :chidren [])
(menu:field :position (g.vec 10 390))
(menu:field :size (g.vec 780 200))
(menu:field :active-ix 1)

(menu:method
  :focused-draw
  {:events [:draw] :state {:focus :focused}}
  (fn [self]
    (rl.DrawRectangleV (+ self.position (g.vec 5 (+ 5 (* self.active-ix 40))))
                       (g.vec 220 40) rl.LIGHTGRAY)))

(menu:method 
  :focused-update 
  {:events [:update] :state {:focus :focused}}
  (fn [self dt]
    (set self.active-ix
      (if (or (rl.IsKeyPressed rl.KEY_DOWN) (rl.IsKeyPressed rl.KEY_S))
          (+ self.active-ix 1)
          (or (rl.IsKeyPressed rl.KEY_UP) (rl.IsKeyPressed rl.KEY_W))
          (- self.active-ix 1)
          self.active-ix))
    (set self.active-ix (math.max 0 (math.min self.active-ix (+ 2 (length self.chidren)))))
    (when (rl.IsKeyPressed rl.KEY_ENTER)
      (print (. self.children (+ self.active-ix 1) :label)))))
      ;(length self.chidren))))
        ; (rl.IsKeyDown rl.KEY_UP)
        ; (set self.active-ix (math.max (- self.active-ix 1) 1)))))
    ; (if (rl.IsKeyDown rl.KEY_ENTER)
    ;   (self.chidren[self.active-ix].on-click))))
  
(menu:method
  :draw-background
  {:events [:draw] :priority -10}
  (fn [self]
    (rl.DrawRectangleV (+ self.position (g.vec 5 5)) self.size rl.BLACK)
    (rl.DrawRectangleV self.position self.size rl.WHITE)))

(menu:method
  :draw-labels
  {:events [:draw] :priority 10}
  (fn [self]
    (each [ix child (ipairs self.children)]
      (rl.DrawText child.label (+ self.position.x 10) (+ self.position.y 10 (* (- ix 1) 40)) 30 rl.BLACK))))

(menu:statemachine :focus :blurred
   {:focus {:from :blurred :to :focused}}
   {:blur {:from :focused :to :blurred}})

(local battle (g.class))
(battle:field :battlefield {})
(battle:field :z-index 100)
(battle:method :init-units {:events [:init]}
  (fn [self]
    (let [state (game-state:get-state)]
      (accumulate [y 100 id unit (pairs state.enemies)]
        (do (tset self.battlefield id {:position (g.vec 640 y) : unit})
            (+ y 70)))
      (accumulate [y 100 id unit (pairs state.team)]
        (do (tset self.battlefield id {:position (g.vec 160 y) : unit})
            (+ y 70))))))

(battle:method :draw {:events [:draw]}
  (fn [self]
    (each [id e (pairs self.battlefield)]
      (if (= e.unit.team :friend)
          (rl.DrawRectangleV e.position (g.vec 50 50) rl.BLUE)
          (= e.unit.team :enemy)
          (rl.DrawRectangleV e.position (g.vec 50 50) rl.RED)))))

(fn on-state-change [scene old-state new-state]
  (print "state changed" (inspect old-state new-state))
  (when (and (not old-state.team) new-state.team)
    (let [m (scene:add-entity (menu {:children [{:label "ATTACK"} {:label "SKILL"} {:label "ITEM"}]}))]
      (m.state.focus:focus)
      (scene:add-entity (battle)))))

(fn main [scene]
  (scene:add-entity (background))
  (game-state:subscribe (partial on-state-change scene))
  (game-state:dispatch :goto-battle {:team [:scout :scout :scout]
                                     :enemies [:monster1 :monster1 :monster1]}))

